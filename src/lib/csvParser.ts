export interface CSVProduct {
  Handle: string;
  Title: string;
  'Body (HTML)': string;
  'Variant Price': string;
  'Variant Compare At Price': string;
  'Image Src': string;
  'Option1 Value': string;
  'Cor (product.metafields.shopify.color-pattern)': string;
  'Tonalidade da maquiagem (product.metafields.shopify.makeup-color-shade)': string;
  'Variant Inventory Qty': string;
  Status: string;
}

export interface ParsedCSVResult {
  success: boolean;
  data: CSVProduct[];
  errors: string[];
  totalRows: number;
  validRows: number;
}

// Fun√ß√£o para validar uma linha do CSV
function validateCSVRow(row: Record<string, string>, lineNumber: number): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  console.log(`üîç Validando linha ${lineNumber + 2}: Handle="${row.Handle}", Title="${row.Title}"`);
  
  // Validar Handle (obrigat√≥rio e deve ser string n√£o vazia)
  if (!row.Handle || typeof row.Handle !== 'string' || row.Handle.trim() === '') {
    const error = `Linha ${lineNumber + 2}: Handle √© obrigat√≥rio e deve ser uma string v√°lida`;
    console.log(`‚ùå ${error}`);
    errors.push(error);
  }
  
  // Validar Title (obrigat√≥rio para produtos principais)
  if (!row.Title || typeof row.Title !== 'string' || row.Title.trim() === '') {
    const error = `Linha ${lineNumber + 2}: Title √© obrigat√≥rio para produtos principais`;
    console.log(`‚ùå ${error}`);
    errors.push(error);
  }
  
  // Validar pre√ßo (opcional - se fornecido, deve ser v√°lido)
  const price = row['Variant Price'];
  if (price && price.trim() !== "" && price.toLowerCase() !== "manual") {
    const cleanPrice = price.toString().replace(',', '.');
    const numericPrice = parseFloat(cleanPrice);
    if (isNaN(numericPrice)) {
      const error = `Linha ${lineNumber + 2}: Pre√ßo n√£o √© um n√∫mero v√°lido: "${price}"`;
      console.log(`‚ùå ${error}`);
      errors.push(error);
    } else if (numericPrice < 0) {
      const error = `Linha ${lineNumber + 2}: Pre√ßo n√£o pode ser negativo: ${numericPrice}`;
      console.log(`‚ùå ${error}`);
      errors.push(error);
    } else {
      console.log(`‚úÖ Pre√ßo v√°lido: ${numericPrice}`);
    }
  } else {
    console.log(`‚ÑπÔ∏è Linha ${lineNumber + 2}: Produto sem pre√ßo - ser√° inclu√≠do para defini√ß√£o posterior`);
  }
  
  const isValid = errors.length === 0;
  console.log(`${isValid ? '‚úÖ' : '‚ùå'} Valida√ß√£o da linha ${lineNumber + 2}: ${isValid ? 'V√ÅLIDA' : 'INV√ÅLIDA'}`);
  
  return {
    isValid,
    errors
  };
}

// Fun√ß√£o para converter CSV text para array de objetos
export function parseCSVText(csvText: string): ParsedCSVResult {
  const result: ParsedCSVResult = {
    success: false,
    data: [],
    errors: [],
    totalRows: 0,
    validRows: 0
  };
  
  console.log('üîç Iniciando parseCSVText...');
  
  try {
    // Dividir em linhas
    const lines = csvText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    console.log(`üìä Total de linhas encontradas: ${lines.length}`);
    
    if (lines.length < 2) {
      result.errors.push('CSV deve ter pelo menos uma linha de cabe√ßalho e uma linha de dados');
      return result;
    }
    
    // Primeira linha s√£o os cabe√ßalhos - usar parser mais robusto
    const headers = parseCSVLine(lines[0]);
    console.log(`üìã Cabe√ßalhos encontrados: ${headers.join(', ')}`);
    
    // Verificar se tem os cabe√ßalhos essenciais
    const requiredHeaders = ['Handle', 'Title', 'Variant Price'];
    const missingHeaders = requiredHeaders.filter(header => !headers.includes(header));
    
    if (missingHeaders.length > 0) {
      result.errors.push(`Cabe√ßalhos obrigat√≥rios ausentes: ${missingHeaders.join(', ')}`);
      return result;
    }
    
    result.totalRows = lines.length - 1; // Excluir linha de cabe√ßalho
    console.log(`üìà Total de linhas de dados para processar: ${result.totalRows}`);
    
    let skippedVariants = 0;
    const skippedNoPrice = 0;
    let validationErrors = 0;
    
    // Processar cada linha de dados
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      console.log(`üîÑ Processando linha ${i}: ${line.substring(0, 100)}...`);
      
      // Usar parser mais robusto
      const values = parseCSVLine(line);
      
      // Criar objeto com os dados da linha
      const rowData: Record<string, string> = {};
      headers.forEach((header, index) => {
        rowData[header] = values[index] || '';
      });
      
      console.log(`üìù Dados da linha ${i}: Handle="${rowData.Handle}", Title="${rowData.Title}", Price="${rowData['Variant Price']}"`);
      
      // Ignorar variantes (linhas sem t√≠tulo)
      if (!rowData.Title || rowData.Title.trim() === '') {
        console.log(`‚è≠Ô∏è Linha ${i}: Ignorando variante (sem t√≠tulo)`);
        skippedVariants++;
        continue;
      }
      
      // Verificar pre√ßo - permitir produtos sem pre√ßo (podem ser definidos depois)
      const priceField = rowData['Variant Price'] || '';
      let hasValidPrice = false;
      
      if (priceField && priceField.trim() !== "" && priceField.toLowerCase() !== "manual") {
        const priceValue = parseFloat(priceField.replace(',', '.'));
        if (!isNaN(priceValue) && priceValue >= 0) {
          hasValidPrice = true;
          console.log(`üí∞ Linha ${i}: Pre√ßo v√°lido: ${priceValue}`);
        } else {
          console.log(`‚ö†Ô∏è Linha ${i}: Pre√ßo inv√°lido "${priceField}" - Produto ser√° inclu√≠do sem pre√ßo`);
        }
      } else {
        console.log(`‚ö†Ô∏è Linha ${i}: Produto sem pre√ßo - Ser√° inclu√≠do para defini√ß√£o posterior`);
      }
      
      // Validar a linha
      const validation = validateCSVRow(rowData, i - 1);
      
      if (validation.isValid) {
        console.log(`‚úÖ Linha ${i}: Produto v√°lido adicionado - Handle: "${rowData.Handle}"`);
        result.data.push(rowData as unknown as CSVProduct);
        result.validRows++;
      } else {
        console.log(`‚ùå Linha ${i}: Falha na valida√ß√£o - Erros: ${validation.errors.join(', ')}`);
        result.errors.push(...validation.errors);
        validationErrors++;
      }
    }
    
    console.log(`üìä Resumo do processamento:`);
    console.log(`   - Variantes ignoradas: ${skippedVariants}`);
    console.log(`   - Produtos sem pre√ßo: ${skippedNoPrice}`);
    console.log(`   - Erros de valida√ß√£o: ${validationErrors}`);
    console.log(`   - Produtos v√°lidos: ${result.validRows}`);
    
    result.success = result.errors.length === 0 && result.validRows > 0;
    
    if (result.validRows === 0 && result.errors.length === 0) {
      result.errors.push('Nenhuma linha v√°lida encontrada no CSV');
    }
    
  } catch (error) {
    console.error('üí• Erro ao processar CSV:', error);
    result.errors.push(`Erro ao processar CSV: ${error}`);
  }
  
  console.log(`üèÅ parseCSVText finalizado. Produtos v√°lidos: ${result.validRows}`);
  return result;
}

// Fun√ß√£o auxiliar para fazer parse robusto de uma linha CSV
function parseCSVLine(line: string): string[] {
  const values: string[] = [];
  let currentValue = '';
  let insideQuotes = false;
  let i = 0;
  
  while (i < line.length) {
    const char = line[i];
    
    if (char === '"') {
      if (insideQuotes && i + 1 < line.length && line[i + 1] === '"') {
        // Aspas duplas escapadas
        currentValue += '"';
        i += 2;
      } else {
        // In√≠cio ou fim de campo com aspas
        insideQuotes = !insideQuotes;
        i++;
      }
    } else if (char === ',' && !insideQuotes) {
      // Separador de campo
      values.push(currentValue.trim());
      currentValue = '';
      i++;
    } else {
      currentValue += char;
      i++;
    }
  }
  
  // Adicionar o √∫ltimo valor
  values.push(currentValue.trim());
  
  return values;
}

// Fun√ß√£o para processar arquivo CSV
export function parseCSVFile(file: File): Promise<ParsedCSVResult> {
  return new Promise((resolve) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const csvText = e.target?.result as string;
      const result = parseCSVText(csvText);
      resolve(result);
    };
    
    reader.onerror = () => {
      resolve({
        success: false,
        data: [],
        errors: ['Erro ao ler o arquivo'],
        totalRows: 0,
        validRows: 0
      });
    };
    
    reader.readAsText(file, 'utf-8');
  });
}

// Fun√ß√£o para validar se o arquivo √© um CSV v√°lido
export function validateCSVFile(file: File): { isValid: boolean; error?: string } {
  // Verificar extens√£o
  if (!file.name.toLowerCase().endsWith('.csv')) {
    return { isValid: false, error: 'Arquivo deve ter extens√£o .csv' };
  }
  
  // Verificar tamanho (m√°ximo 10MB)
  if (file.size > 10 * 1024 * 1024) {
    return { isValid: false, error: 'Arquivo muito grande. M√°ximo 10MB' };
  }
  
  // Verificar se n√£o est√° vazio
  if (file.size === 0) {
    return { isValid: false, error: 'Arquivo est√° vazio' };
  }
  
  return { isValid: true };
}